<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Kaggle实战：Digit Recognizer]]></title>
    <url>%2F2018%2F11%2F20%2FKaggle%E5%AE%9E%E6%88%98%EF%BC%9ADigit-Recognizer%2F</url>
    <content type="text"><![CDATA[1. Data preparation 1.1 Load data 1.2 Check for null and missing values 1.3 Normalization 1.4 Reshape 1.5 Label encoding 1.6 Split training and valdiation set 2. CNN 2.1 Define the model 2.2 Set the optimizer and annealer 2.3 Data augmentation 3. Evaluate the model 3.1 Training and validation curves 3.2 Confusion matrix 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110# Data preparation#load datapd.read_csv#check data train.isnull().any().describe()train.head()train.describe()#Normolization # CNN deal with numbers in [0,1] faster then [0,255]train/255.0#reshapereshape image in 3-dimentionstrain.values.reshape(height,width,canal)#label encodingtrain_y = to_categorical(train_y,numberclasses)#split training and validation setstrain_test_split()----------# CNN model#define model#CNN architechture for example:#In -&gt; [[Conv2D-&gt;relu]*2 -&gt; MaxPool2D -&gt; Dropout]*2 -&gt; Flatten -&gt; Dense -&gt; Dropout -&gt; Outmodel = Sequential()model.add()#set optimizer and annealerkeras.optimizers.SGD(lr, momentum, decay, nesterov=False)keras.optimizers.RMSprop(lr, rho, epsilon=None, decay)compile(optimizer, loss=None, metrics=None, loss_weights=None, sample_weight_mode=None, weighted_metrics=None, target_tensors=None)learning_rate_reduction = ReduceLROnPlateau(monitor=&apos;val_acc&apos;, patience, verbose, factor, min_lr)epochesbatch_size#Data augmentation#to prevent overfitting ImageDataGenerator(featurewise_center=False, # set input mean to 0 over the datasetsamplewise_center=False, # set each sample mean to 0featurewise_std_normalization=False, # divide inputs by std of the datasetsamplewise_std_normalization=False, # divide each input by its stdzca_whitening=False, # apply ZCA whiteningrotation_range=10, # randomly rotate images in the range (degrees, 0 to 180)zoom_range = 0.1, # Randomly zoom image width_shift_range=0.1, # randomly shift images horizontally (fraction of total width)height_shift_range=0.1, # randomly shift images vertically (fraction of total height)horizontal_flip=False, # randomly flip imagesvertical_flip=False) # randomly flip imageshistory = model.fit_generator(datagen.flow(X_train,Y_train, batch_size=batch_size),epochs = epochs, validation_data = (X_val,Y_val),verbose = 2, steps_per_epoch=X_train.shape[0] // batch_size, callbacks=[learning_rate_reduction])----------# Evaluate the model# Plot the loss and accuracy curves for training and validation fig, ax = plt.subplots(2,1)ax[0].plot(history.history[&apos;loss&apos;], color=&apos;b&apos;, label=&quot;Training loss&quot;)ax[0].plot(history.history[&apos;val_loss&apos;], color=&apos;r&apos;, label=&quot;validation loss&quot;,axes =ax[0])legend = ax[0].legend(loc=&apos;best&apos;, shadow=True)ax[1].plot(history.history[&apos;acc&apos;], color=&apos;b&apos;, label=&quot;Training accuracy&quot;)ax[1].plot(history.history[&apos;val_acc&apos;], color=&apos;r&apos;,label=&quot;Validation accuracy&quot;)legend = ax[1].legend(loc=&apos;best&apos;, shadow=True)# Look at confusion matrix def plot_confusion_matrix(cm, classes,normalize=False,title=&apos;Confusion matrix&apos;,cmap=plt.cm.Blues):&quot;&quot;&quot;This function prints and plots the confusion matrix.Normalization can be applied by setting `normalize=True`.&quot;&quot;&quot;plt.imshow(cm, interpolation=&apos;nearest&apos;, cmap=cmap)plt.title(title)plt.colorbar()tick_marks = np.arange(len(classes))plt.xticks(tick_marks, classes, rotation=45)plt.yticks(tick_marks, classes)if normalize:cm = cm.astype(&apos;float&apos;) / cm.sum(axis=1)[:, np.newaxis]thresh = cm.max() / 2.for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):plt.text(j, i, cm[i, j],horizontalalignment=&quot;center&quot;,color=&quot;white&quot; if cm[i, j] &gt; thresh else &quot;black&quot;)plt.tight_layout()plt.ylabel(&apos;True label&apos;)plt.xlabel(&apos;Predicted label&apos;)# Predict the values from the validation datasetY_pred = model.predict(X_val)# Convert predictions classes to one hot vectors Y_pred_classes = np.argmax(Y_pred,axis = 1) # Convert validation observations to one hot vectorsY_true = np.argmax(Y_val,axis = 1) # compute the confusion matrixconfusion_mtx = confusion_matrix(Y_true, Y_pred_classes) # plot the confusion matrixplot_confusion_matrix(confusion_mtx, classes = range(10))]]></content>
      <tags>
        <tag>kaggle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2D横版游戏小结powered by GameMaker2]]></title>
    <url>%2F2018%2F09%2F26%2F2D%E6%A8%AA%E7%89%88%E6%B8%B8%E6%88%8F%E5%B0%8F%E7%BB%93powered-by-GameMaker2%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[算法小结快慢指针]]></title>
    <url>%2F2018%2F09%2F24%2F%E7%AE%97%E6%B3%95%E5%B0%8F%E7%BB%93%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;总结一些算法问题的思路和技巧，在处理链表的问题中经常会遇到寻找链表中间节点这样的问题，快慢指针(fast-slow pointer)就是一个很不错的工具。直接看题:A.判断链表是否有环并输出环入口节点 Linked List CycleGiven a linked list, determine if it has a cycle in it. Linked List Cycle IIGiven a linked list, return the node where the cycle begins. If there is no cycle, return null.142相较于141多了一个寻找环入口的步骤。这里给出142的代码： 1234567891011121314151617def FindListCycle(head): if not head: return None fast = slow = head#寻找是否存在环 while fast and fast.next: slow = slow.next fast = fast.next.next if fast == slow: break else: return None#找到环的入口 while head != slow: slow = slow.next fast = fast.next return head 利用快慢指针寻找环入口的数学原理：第一个循环中快慢指针相遇表示链表存在环，设slow走了N个节点；fast则走了2N个节点两指针相遇。此时保持两节点位置，让head从链表头遍历链表，head指针保持和slow一样每次一步的速度前进必定在slow走到2N(head走到N)时两指针相遇。在此位置之前相遇，相遇点即为环入口或是直到2N点初才相遇2Indian即是入口。 B.寻找链表中点 1234567def FindMiddleNode(head): if not head or not head.next: return None fast,slow = head while fast and fast.next: slow,fast = slow.next,fast.next.next return slow Sort ListSort a linked list in O(n log n) time using constant space complexity. 123456789101112131415161718192021def sortList(head): if not head or not head.next: return head # use fast-slow pointers to find the middle of the list # find the middle node and then sperate the list into two parts pre,slow,fast = None,head,head while fast and fast.next: pre,slow,fast = slow,slow.next,fast.next.next pre.next = None return self.merge(*map(self.sortList,(head,slow))) #merge sort def merge(self,h1,h2): dummy = tail = ListNode(None) while h1 and h2: if h1.val &lt; h2.val: tail.next,tail,h1 = h1,h1,h1.next else: tail.next,tail,h2 = h2,h2,h2.next tail.next = h1 or h2 return dummy.next Palindrome Linked ListGiven a singly linked list, determine if it is a palindrome.这道题可以利用list将每个节点的val存下来然后利用list的reverse方法翻转list与原来的list进行比较；不过要想达到空间复杂度O(1)则需要找到中间节点翻转后半节点进行比较。 123456789101112131415161718192021222324#方法一:使用list翻转，空间复杂度O(n)def isPalindrome(head): vals = [] while head: vals += head.val head = head.next return vals == vals[::-1]#方法二:使用快慢指针找中节点翻转后半链表def isPalindrome(head): fast = slow =head while fast and fast.next: slow,fast = slow.next,fast.next.next prev = None while slow: tmp = slow.next slow.next = prev prev = slow slow = tmp while slow: if slow.val != head.val: return False slow = slow.next head = head.next return True 遇到其他问题再更新…..]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Day 1 HongKong]]></title>
    <url>%2F2018%2F08%2F22%2FDay-1-HongKong%2F</url>
    <content type="text"><![CDATA[8月21号早上乘6：30的地铁来到福田口岸，地铁上还是有蛮多的人，急急忙忙上班的人，其实看得出来大家都挺不容易，可能每天上班都的很早起床然后挤公交。 从口岸过到香港这边乘坐东铁线到旺角东站，一路上感觉蛮累的，旁边人讲话也听不太懂。还是有一点陌生的感觉虽然都是黄皮肤的中国人。之前听阿姨讲内地来的和香港本地人会有很大的区别，一眼就能看出是内地过来的。我是没什么感觉了，不过香港上班族们好像都是西装领带，正装比较多一点其他没什么不一样。 来港之前在家最后一晚失眠挺严重的，感觉心里跳个不停。还是有一点舍不得家，舍不得父母和那种温馨的氛围。家里确实是我的舒适区，在家里都不怎么学习。哈哈，来到香港要好好的利用这边的资源，做一个积极的人了。 拖着行李来到公寓，3个小伙伴都先到了。其中一个的父母在给我们准备午餐，挺幸运的。一来就蹭到一顿吃喝。 然后收拾了一下自己的屋子，下楼买了一点生活用品。室友都挺热心的，感觉和大学宿舍的室友风格不太一样。可能心底里我还是更喜欢那一群老逼————他们是真的皮，好玩一点。 晚上约了上一届的一个学长，在理工的校园转了一转。第一次见到学长，学长面相比较man。上楼下楼各个楼里转悠，学长也是满头大汗，晚上和学长一起去红磡冰室吃了晚饭。 回来的路上，香港的老街还是很有味道，市井气息很浓。浓到我在楼下杂货铺买东西只能跟老板写汉字。这边的店员挺负责的，希望能充实的度过这一年。 # 生活的意义就是不断寻找生活意义的勇气。]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KMP 算法笔记]]></title>
    <url>%2F2018%2F08%2F05%2FKMP-%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[KMP算法是一种高效的串的模式配算法，由D.E.Knuth 与 V.R.Pratt 和 J.H.Morris 同时发现，因此被称为KMP算法。该算法可以在O（n+m)的时间数量级上完成串的模式匹配。 之前看过KMP算法的相关原理，无奈时间一长就渐渐淡忘了，现将学习笔记写入blog以备不时之需。 KMP算法俗称“看毛片”算法原理比较复杂比较绕，网上的博客有各种方向来理解他的，我将选用最容易理解的方式，简单形象的把他讲清楚。 整体把握 KMP算法的核心：模式串自身的相关性。即不匹配时模式串利用成功匹配的部分能将串后移的最大位数K。这是区别于传统模式匹配的地方。 Next函数的定义及计算在KMP算法匹配中原始串的索引 i 不会因不匹配而回退，利用Next函数调整模式串索引 j 值。当匹配失败时，利用当前 j 值求得 K = Next [ j ]，K即为最大右移量。使新的 j = K 继续匹配。Next的值实际上是对每个位置找最长公共前缀。 Next函数值的算法如下: 12345678910void get_next ( char T[],int next [])&#123; int i = 1, j = 0; next[1]=0; while(i&lt;=T[0])&#123; if(j==0||T[i]==T[j])&#123; ++i,++j,next[i]=j;&#125; else j=next[j]; &#125;&#125; 举例：求下面序列的Next数组值a b a a c b a b a(1)设next[1]=0,next[2]=1; 编号 1 2 3 4 5 6 7 8 9 S a b a a c b a b a next 0 1 1 2 2 1 1 2 3 (2)当 j = 3 时，K=next[ j -1]=1，因为是S[2]=b，S[K]=S[1]=a!=S[2]，此时K=next[K]=0,所以next[j]=K+1=1;(3)当 j=4时，K=next[ j -1]=1，因为是S[3]=a，S[K]=S[1]=a=S[3]，此时next[j]=k+1=2;(4)当 j=5时，K=next[ j -1]=2，因为是S[4]=a，S[K]=S[2]=b!=S[4]，此时K=next[K]=1,S[K]=S[4],所以next[j]=K+1=2;同理求出各个位置的next值。 KMP的匹配算法 相较于Next数组的求解过程，KMP的匹配算法理解了。 原始串的索引不断向前移动与模式串进行匹配，当匹配失败的将模式串的索引移至next[j]数组值的位置进行匹配直到匹配成功或是原始串末尾。 算法如下： 123456789101112131415int KMP (char s[],int next[],int pos)&#123; int i=pos; int j=1; while(i&lt;S[0]&amp;&amp;j&lt;T[0])&#123; //S[0],T[0]分别储存原始串和模式串的长度 if(j==0||S[i]==T[j])&#123; i++,j++; &#125; else j=next[j]; &#125; if (j&gt;T[0]) return i-t[0]; else return 0; &#125; 举例： 主串为：abcabaacabaacbaba，模式串为:abaacbaba，pos = 0： (1)初始化i=j=1; a b c a b a a c a b a a c b a b a a b a a c b a b a (2)S[1]=T[1]自加直到i=j=3时匹配失败，j=next[3]=1; a b c a b a a c a b a a c b a b a a b a a c b a b a (3)S[3]!=T[1],j=next[1]=0,模式串后移一位; a b c a b a a c a b a a c b a b a a b a a c b a b a (4)S[4]=T[1]自加匹配继续，直到i=9,j=6时匹配失败，j=next[6]=1; a b c a b a a c a b a a c b a b a a b a a c b a b a (5)匹配成功返回值：i-t[0]=17-9=8; 小结： KMP算法中核心部分为Next数组的求解，其中用到了动态规划的思想反复解算目标位置的next值，在这里没有对动态规划进行展开说明，接下来将以此为主题写几篇博文。]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>模式匹配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈与队列算法题小结]]></title>
    <url>%2F2017%2F10%2F16%2F%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E7%AE%97%E6%B3%95%E9%A2%98%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[一、getMin功能的栈 要求：a.在栈的基本功能上增加getmin返回栈内最小的元素; b.各种操作时间复杂度为O(1) 【解答】1.算法思想： a.总共两个栈stack_data 和 stack_min，stack_data 用于存放所有元素；stack_min 存放当前data栈中的最小元素 b.入栈时：设入栈元素为 cur,当stack_min栈为空时，cur压入stack_data栈时也压入min栈；当stack_min不为空时,需要比较cur与min 栈栈顶元素的大小：若 cur &lt;= stack_min.peek(),则cur压入min栈；否则不压。 c.出栈时：需要比较cur=stack_data.pop()与stack_min.peek():若cur=stack_min.peek(),则stack_min需弹出栈顶元素。 2.代码 123456789101112131415161718192021222324252627282930313233343536373839#getmin_stackimport collectionsclass getmin_stack(object): def __init__(self): self.stack_data=[] self.stack_min=[] def isEmpty(self): return self.stack_data==0 def push(self,element): self.stack_data.append(element) if len(self.stack_min)== 0: self.stack_min.append(element) else: a= self.stack_min[-1] if a &gt;= element: self.stack_min.append(element) print('data', self.stack_data) print('min', self.stack_min) def Pop(self): if not self.isEmpty(): if self.stack_data[-1]==self.stack_min[-1]: self.stack_min.pop() return self.stack_data.pop() def GetMin(self): if len(self.stack_min)!=0 : return self.stack_min[len(self.stack_min)-1]a=getmin_stack()a.push(2)a.push(3)a.push(2)a.push(1)print(a.GetMin())a.push(5)print(a.Pop())print(a.Pop())print(a.GetMin())print(a.Pop())print(a.GetMin())a.push(8) 二、由两个栈组成队列 要求：a.用两个栈来实现队列的基本操作(add, poll, peek)hsdjakuhdksua]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python yield 使用]]></title>
    <url>%2F2017%2F10%2F08%2FPython-yield-%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Ugly Numbers UVa 136]]></title>
    <url>%2F2017%2F07%2F07%2FUgly-Numbers-UVa-136%2F</url>
    <content type="text"><![CDATA[这道题解中用到了priority_queue和set两个stl容器。是熟悉stl容器类很好的例子。 Ugly numbers are numbers whose only prime factors are 2, 3 or 5. The sequence1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, …shows the first 11 ugly numbers. By convention, 1 is included.Write a program to find and print the 1500’th ugly number.InputThere is no input to this program.OutputOutput should consist of a single line as shown below, with ‘’ replaced by the number computed.Sample OutputThe 1500’th ugly number is . 12345678910111213141516171819202122232425262728#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;iostream&gt;using namespace std;typedef long long LL;const int coeff[3]=&#123;2,3,5&#125;;int main()&#123; priority_queue&lt;LL, vector&lt;LL&gt;, greater&lt;LL&gt; &gt; pq; set &lt;LL&gt; q; pq.push(1); s.insert(1); for(int i=0; ;i++)&#123; LL x = pq.top(); pq.pop(); if( i==1500)&#123; cout &lt;&lt; "The 1500'th ugly number is "&lt;&lt;x&lt;&lt;"./n"; break; &#125; for(int j=0;j&lt;3;j++)&#123; LL x2=x*coeff[j]; if(!s.count(x2))&#123; s.insert(x2);pq.push(x2);&#125; &#125; &#125; return 0;&#125; 1.]]></content>
      <tags>
        <tag>UVa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flooded! UVa815]]></title>
    <url>%2F2017%2F06%2F03%2FFlooded-UVa815%2F</url>
    <content type="text"><![CDATA[Recently, I am reading a book about ACM. In the Chapter 4, there is a exercise about my major. The book’s author tuck a few words on to the tail. Commend reader to solve this problem in different ways.I will use some special analytical method to resolve this problem. UVa815 —– Flooded! Description To enable homebuyers to estimate the cost of flood insurance, a real-estate firm provides clients with the elevation of each 10-meter by 10-meter square of land in regions where homes may be purchased. Water from rain, melting snow, and burst water mains will collect first in those squares with the lowest elevations, since water from squares of higher elevation will run downhill. For simplicity, we also assume that storm sewers enable water from high-elevation squares in valleys (completely enclosed by still higher elevation squares) to drain to lower elevation squares, and that water will not be absorbed by the land. From weather data archives, we know the typical volume of water that collects in a region. As prospective homebuyers, we wish to know the elevation of the water after it has collected in low-lying squares, and also the percentage of the region’s area that is completely submerged (that is, the percentage of 10-meter squares whose elevation is strictly less than the water level). You are to write the program that provides these results.InputThe input consists of a sequence of region descriptions. Each begins with a pair of integers, m and n, each less than 30, giving the dimensions of the rectangular region in 10-meter units. Immediately following are m lines of n integers giving the elevations of the squares in row-major order. Elevations are given in meters, with positive and negative numbers representing elevations above and below sea level, respectively. The final value in each region description is an integer that indicates the number of cubic meters of water that will collect in the region. A pair of zeroes follows the description of the last region.OutputFor each region, display the region number (1, 2, …), the water level (in meters above or below sea level) and the percentage of the region’s area under water, each on a separate line. The water level and percentage of the region’s area under water are to be displayed accurate to two fractional digits. Follow the output for each region with a blank line.Sample Input 3 325 37 4551 12 3494 83 27100000 0 Sample Output Region 1Water level is 46.67 meters.66.67 percent of the region is under water. Flooding model: function between the volume of flooding eare (V) and the altitude of the flood level (H): V = ∑ Ai * ( H - Ei) Ai–the area of flooded grid; Ei–the altitude of flooded grid; so the key of the problem is to choose the optimal H. c++ code 1234567891011121314151617181920212223242526272829303132333435363738394041# include &lt;cstdio&gt;# define minn 0.1# define mann 25vector &lt;double&gt; a[maxn]double compute( int i,int j,double vo,double h)&#123; double v; for(int i=0;i&lt;m;i++)&#123; for(int j=0;j&lt;n;j++)&#123; while(h-a[i][j] &gt; 0) v+=(h-a[i][j]); &#125; &#125; return v; &#125;int main()&#123; int m,n; double x,vo,v=0.0,al; int maxx,miin=0; scanf("%d%d", &amp;m, &amp;n); for (int i=0;i&lt;m;i++)&#123; for (int j=0;j&lt;n;j++)&#123; scanf("%f",&amp;x); a[i][j]=x; &#125; &#125; scanf("%f",&amp;vo); vo /= 100; maxx=vo; al=(maxx+miin)/2; while(abs(v-vo) &gt; 0.1)&#123; if(v-vo &gt; 0)&#123; maxx = al; al = (al + miin )/2; compute( m, n, vo, al); &#125; if(v-vo &lt; 0)&#123; miin = al; al = (al + maxx)/2; compute(m, n, vo,al); &#125; printf("%f",&amp;al); &#125;]]></content>
      <tags>
        <tag>UVa</tag>
        <tag>GIS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT (Advanced Level) 1003]]></title>
    <url>%2F2017%2F05%2F17%2FPAT-Advanced-Level-1003%2F</url>
    <content type="text"><![CDATA[Dijkstra算法遍历有向图过程中记录目标值，第一次实战Dijkstra，有点小激动，问题也不少。 Emergency (25) As an emergency rescue team leader of a city, you are given a special map of your country. The map shows several scattered cities connected by some roads. Amount of rescue teams in each city and the length of each road between any pair of cities are marked on the map. When there is an emergency call to you from some other city, your job is to lead your men to the place as quickly as possible, and at the mean time, call up as many hands on the way as possible. Input Each input file contains one test case. For each test case, the first line contains 4 positive integers: N (&lt;= 500) - the number of cities (and the cities are numbered from 0 to N-1), M - the number of roads, C1 and C2 - the cities that you are currently in and that you must save, respectively. The next line contains N integers, where the i-th integer is the number of rescue teams in the i-th city. Then M lines follow, each describes a road with three integers c1, c2 and L, which are the pair of cities connected by a road and the length of that road, respectively. It is guaranteed that there exists at least one path from C1 to C2. Output For each test case, print in one line two numbers: the number of different shortest paths between C1 and C2, and the maximum amount of rescue teams you can possibly gather.All the numbers in a line must be separated by exactly one space, and there is no extra space allowed at the end of a line.Sample Input 5 6 0 21 2 1 5 30 1 10 2 20 3 11 2 12 4 13 4 1 Sample Output 2 4问题描述:讲了个故事，有若干个城市，城市之间有若干条带权有向路径，每个城市都驻扎着若干救援队，求当某个城市发生紧急状况需要救援时，到该城市的最短路径有几条，并输出救援队数目(如有多条最短路径输出救援队数目最多的) C++代码:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152# include &lt;cstdio&gt;# include &lt;algorithm&gt;using namespace std;const maxn = 505;int map[maxn][maxn],v[maxn]; //储存有向图的边权有向图的顶点属性值，int visit[maxn],dist[maxn],num[manx],vs[maxn]; //算法中的辅助数组分别是访问数组，最短路径数组，路径数量数组int m,n,c1,c2,v,a,b,e;int main()&#123;//----------------建立相应的数据结构，完成数据初始化------------------- scanf("%d%d%d%d",&amp;m,&amp;n,&amp;c1,&amp;c2); memset(map,maxn,sizeof(map)); memset(v,manx,sizeof(v)); for( int i=0;i&lt;m;i++)&#123; scanf("%d",&amp;v); v[i]=v; &#125; for( int i=0;i&lt;n;i++)&#123; scanf("%d%d%d",&amp;a,&amp;b,&amp;e); map[a][b]=map[b][a]=e; &#125;//--------------Dijkstra遍历部分------------------------------- memset(visit,0,sizeof(visit)); dist[c1]=0; vs[c1]=v[c1]; num[c1]=1; for( int i=0;i&lt;m;i++)&#123; int now=-1,min=maxn; for( int j=0;j&lt;m;j++)&#123; if( !visit[j] &amp;&amp; dist[j] &lt; min)&#123; u=j; min=dist[j]; &#125; &#125; //寻找未访问的最小权值边所在顶点j if(u==-1)break; visit[j]=1; for( int k=0;k&lt;n;k++)&#123; if( !visit[k] &amp;&amp; map[u][k] &lt; maxn)&#123; if(dist[u]+map[u][k]&lt;dist[k])&#123; dist[k]=dist[u]+map[u][k]; num[k]=num[u]; vs[k]=vs[u]+v[k]; &#125; else if (dist[u]+map[u][k] = dist[k])&#123; num[k]+=num[u]; if(vs[u]+v[k]&gt;vs[k])vs[k]=vs[u]+v[k]; &#125; &#125; &#125; &#125; printf("%d%d",num[c2],vs[c2]); return 0;&#125;]]></content>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dijkstra 算法笔记]]></title>
    <url>%2F2017%2F05%2F17%2FDijkstra-%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[关于Dijkstra算法的本质是贪心算法还是动态规划，大家可以去看看大牛们的理解，作为一个学习者我也没什么独到的理解，不过看看大家的观点也没什么害处，毕竟兼听则明。 Dijkstra算法是求解单源最短路径的有效方法。一、相关辅助数组 Visit[]: 记录是否访问过某个节点，当visit[vi]=1时，表示将顶点vi 放入visit[]中； dist[]: 记录从源点v0到各顶点当前的最短路径长度，dist[]初值为ma p[vo][i]; path[]: path[i]表示从源点到顶点i的最短路径的前驱节点。 二、算法步骤 假设从顶点0出发，即v0=0，集合visit[]最初只包含顶点0，v[] 表示顶点集合及其属性值。邻接矩阵 map 表示带权有向图，map[i][j]表示有向边 &lt;i,j&gt; 的权值，若不存在 &lt;i,j&gt;,则map[i][j]为 ∞。 1).初始化: 集合visit[]初始化为{0}，dist[]的初始值 dist[] = map[0][i]; 2).从顶点集合v-visit中选出vj，满足dist[j] = Min { dist[j] | vi ∈ v-visit },vj就是求得一条从v0出发的最短路径的终点，把 j 加入visit[]； 3).修改从v0出发到集合v-visit上任意一点vk可达到的最短路径长度:如果 dist[j]+map[j][k] &lt; dist[k],则dist[k] = dist[j]+map[j][k]; 4).重复2)-3)操作n-1次，直到所有顶点都包含在visit[]中； 三、实例 例如，如下有向图求解从图中顶点0出发，到其余顶点的最短路径： 顶点 第一趟 第二趟 第三趟 第四趟 1 v0→v1 100 v0→v2→v1 90 v0→v4→v3→v1 70 2 v0→v2 30 v0→v2 30 3 v0→v4→v3 60 v0→v4→v3 60 4 v0→v4 10 visit {0,4} {0,4,2} {0,4,2,3} {0,4,2,3,1} 上表反映了例中有向图使用Dijkstra算法求顶点0到各顶点最短路径的过程。 四、相关习题 在算法题解的过程中有关Dijkstra算法的题会贴到下面: 大家可以从习题求解的过程中更好的理解Dijkstra算法。]]></content>
      <tags>
        <tag>最短路径</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法思想——动态规划(Dynamic programing)]]></title>
    <url>%2F2017%2F05%2F15%2F%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-Dynamic-programing%2F</url>
    <content type="text"><![CDATA[WebGis的课程上老师让有个小组展示，主要内容是最近所学，最近学习算法，思来想去干脆做个有关算法思想的介绍。 概念： 动态规划(Dynamic programing)中:Dynamic当然是动态的意思了。然而programing却有另一种解释:”programing”指的是一种表格法，并非编写计算机程序。(这是《算法导论》上的解释）。动态规划常用来解决最优化问题，与分治法十分相似，其基本原理是将待求问题分为若干子问题，通过求解子问题得到原问题的解。 适用条件： 1&gt;最优化原理:一个最优化策略具有这样的性质，不论过去状态和决策如何，对前面的决策所形成的状态而言，余下的诸决策必须构成最优策略。简而言之，一个最优化策略的子策略总是最优的。 2&gt;无后效性:以前各阶段的状态都无法直接影响它未来的决策，每个状态都是对过去的一个完整总结。 3&gt;子问题重叠性:动态规划将原来具有指数级时间复杂度的搜索算法改进成了具有多项式时间发杂度的算法，是一种牺牲空间换时间的算法。 以01背包为例理解动态规划原理及特点： 01背包问题:给出物品重量 W[n]={w1,w2,w3,w4,w5…,wn},物品价值 V[n]={v1,v2,v3,v4,v5….vn},以及背包最大承重量 c=K，求背包能容纳的最大价值为多少？ (PS:每种物品只能选一次，对于物品而言1代表选，而0为不选，因此命名“01背包问题”) 例. 物品重量W[5]={2,3,6,4},物品价值 V[5]={4,7,15,10},背包最大承重量 c=10,求能容纳的最大价值？ 设m[i][j]表示可选物品为i…n背包容量为j时背包能容纳物品的最大值。 价值重量表： w 0 2 3 6 4 v 0 4 7 15 10m[i][j]表: 0 1 2 3 4 5 6 7 8 9 10 1 0 2 7 10 11 15 17 19 19 25 2 0 0 7 10 10 15 17 17 17 25 3 0 0 0 10 10 15 15 15 15 25 4 0 0 0 10 10 10 10 10 10 10 12345678m[i][j]=&#123; if(j&gt;=wi) max&#123; m[i+1][j],m[i+1][j-wi]+vi&#125;; if(0&lt;=j&lt;=wi) m[i+1][j] &#125;m[n][j]=&#123; if(j&gt;=wn) vn; if(j&lt;wn) 0 &#125; 根据以上原则，自底而上，从左至右填充m[i][j]表，最终m[1][10]即为结果。]]></content>
      <tags>
        <tag>算法思想</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT(Advanced Level) 1002]]></title>
    <url>%2F2017%2F05%2F12%2FPAT-Advanced-Level-1002%2F</url>
    <content type="text"><![CDATA[1002题一道25分的题是甲级考试中中等难度的题，和昨天的那题不太一样。C++部分我很快就有了思路，比较轻松的完成了这部分；至于Python部分头有点大，各种字符串切片划分操作忘得一干二净，一晚上都在痛苦的报错。 A+B for Polynomials (25) This time, you are supposed to find A+B where A and B are two polynomials. Input Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial: K N1 aN1 N2 aN2 … NK aNK, where K is the number of nonzero terms in the polynomial, Ni and aNi (i=1, 2, …, K) are the exponents and coefficients, respectively. It is given that 1 &lt;= K &lt;= 10，0 &lt;= NK &lt; … &lt; N2 &lt; N1 &lt;=1000. Output For each test case you should output the sum of A and B in one line, with the same format as the input. Notice that there must be NO extra space at the end of each line. Please be accurate to 1 decimal place.Sample Input 2 1 2.4 0 3.22 2 1.5 1 0.5 Sample Output 3 2 1.5 1 2.9 0 3.2 问题描述:两多项式相加求和问题；输入:两行分别代表两个多项式，第一个数字为项数，后面依次为指数，系数，指数，系数…….输出:同输入格式一致表示结果 Python代码: 1占个坑.... C++代码: 1234567891011121314151617181920212223242526# include &lt;cstdio&gt;using namespace std;const int maxn = 1010;float rs[maxn],f;int n,a;int cnt=0;int main()&#123; for (int i=0;i&lt;2;i++)&#123; scanf("%d",&amp;n); while(n--)&#123; scanf("%d%f",&amp;a,&amp;f); rs[a]+=f; &#125; &#125; for (int i=0;i&lt;maxn;i++)&#123; if(rs[i]!=0)cnt++; &#125; printf("%d",cnt); for (int i=maxn-1;i&gt;=0;i--)&#123; if(rs[i]!=0)&#123; printf(" %d %.1f",i,rs[i]); &#125; &#125; printf("\n"); return 0;&#125; 总结:1.C++部分即是用好数组，简化问题；2.至于Python部分的代码为什么还没贴，我写的感觉还不太满意，不是特别pythonic，会补上的；]]></content>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT (Advanced Level) 1001]]></title>
    <url>%2F2017%2F05%2F11%2FPAT-Advanced-Level-1001%2F</url>
    <content type="text"><![CDATA[今天终于开始了PAT甲级题库，为了9月份的PAT考试，题库的每一道题我都会写进博客里的。之前学过的Python发现忘得很厉害很彻底，所以我准备每题都写Python和C++两个版本，至于其他语言好像无缘了，毕竟考研很多事情。代码我会放到我的GitHub，如果有迷路的盆友有兴趣，可以找我玩耍呀！ ——————————————-这是分割线———————————————————- A+B Format (20)Calculate a + b and output the sum in standard format – that is, the digits must be separated into groups of three by commas (unless there are less than four digits).Input Each input file contains one test case. Each case contains a pair of integers a and b where -1000000 &lt;= a, b &lt;= 1000000. The numbers are separated by a space. Output For each test case, you should output the sum of a and b in one line. The sum must be written in the standard format.Sample Input -1000000 9 Sample Output -999,991问题描述：输入a,b两个整数，空格隔开；格式化输出两者和； Python代码： 12345def formatout(contents): num = map(int,contents.split()) num = num[0] + num[1] return '&#123;:,&#125;'.format(num)print formatout(raw_input()) C++代码： 123456789101112131415161718192021222324252627# include &lt;cstdio&gt;# include&lt;iostream&gt;# include&lt;cstring&gt;using namespace std;int main()&#123; int a,b,c,k,num[100000]; int i=0; scanf("%d%d",&amp;a,&amp;b); c=a+b; if(c&lt;0)&#123; c=-c; printf("-"); &#125; while(c)&#123; num[i++]=c%10; c/=10; &#125; for(k=i-1;k&gt;=0;k--)&#123; printf("%d",num[k]); if(k%3 == 0 &amp;&amp; k) printf(","); &#125; if(!i)printf("0"); printf("\n"); &#125; 总结： 1.Map/Reduce: 提到Map函数不得不提Google大名鼎鼎的论文:MapReduce:simplified data processing on large clusters还有这篇国人的例子很生动 用通俗易懂的大白话讲解Map/Reduce原理 2.raw_input ()和input():简而言之input ()函数接受输入时，内容必须符合Python语法规则即input()函数返回值带有数据类型(int,float,str…);raw_input()则把输入内容一律按字符串返回。]]></content>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[这是一篇测试文你可以不应看了]]></title>
    <url>%2F2017%2F05%2F07%2F%E8%BF%99%E6%98%AF%E4%B8%80%E7%AF%87%E6%B5%8B%E8%AF%95%E6%96%87%E4%BD%A0%E5%8F%AF%E4%BB%A5%E4%B8%8D%E5%BA%94%E7%9C%8B%E4%BA%86%2F</url>
    <content type="text"><![CDATA[你还是点开了……诶！？调皮。这是刀塔没我炉石没我（曾用名：全自动打屁屁机）的Blog，简单几句话解决这一篇： -上帝已死-英雄不朽-跳刀躲梅肯-死吧！虫子！]]></content>
  </entry>
</search>
