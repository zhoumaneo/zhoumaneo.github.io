<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[The Chicken]]></title>
    <url>%2F2019%2F11%2F21%2FThe-Chicken%2F</url>
    <content type="text"><![CDATA[The ChickenToday is a great special meaningful remarkable day.The number of our compatriots has reached 22 billion. Is one of the most successful species on the planet. ———— Chicken King “从后往前看，我们鸡的历史发展，我们数量增长曲线啊是一个又一个的‘S’曲线，伟大的物种啊！在历史的考验中，都会有一个伟鸡带领大家走出危鸡！寻求到突破。历史进程中，前人们为子孙后代打下了社会基础，确定了发展方向。我们要去传承、去发展。今天、或者说每一天、都应该早上起来，拥抱太阳。为了我们的大业去工作去奉献。” 鸡舍中，一只鸡气宇轩昂的说道。其他的鸡也随声附和，感觉到打了鸡血一样的异常鸡动。（ps：晨间鸡会是是不可动摇的传统，是立鸡之本。没有一只鸡能缺席晨间鸡会当然也没有一只鸡能拒绝。 ————《鸡史·本纲·那只鸡》**pss:10000年前，那只鸡提出著名的《管住腿，张开嘴》理论，鸡史上第一次出现鸡口数量高速增长。） 鲍勃，从鸡会解散后回到自己的工位，早上5点起床，然后是参加晨间鸡会。6点来到工位开始了一天的工作。广播里播放的新闻：“鸡口数量全球达突破220亿大关，每一只鸡都应该为此感到骄傲，我们是这个星球最成功的物种，我们的基因保有量证明了我们对于各种环境的适应都是最棒的。”（ps:《基因保有学说》：“只有最优秀的基因才能适应各种各样的生存环境，最成功的物种应该是星球上数量最多的物种，生存是第一要义。”达尔鸡是鸡史上第二位伟鸡，他提出了物种发展的最终机目标———保有自己的基因。他给了世界一个目标，统一了鸡们的思想。）鲍勃脸上洋溢着微笑，他看看这越来越大的鸡舍，数量越来越大的同胞们。再看看自己粗壮的身体，虽然小小的工位和自己小小的生存空间可能让他有点难受，但是在全鸡的共同目标下，做一个“螺丝钉”有何不可呢。 和以往的日子一样，到了放工的时间。广播里的消息令每一只鸡都洋溢自豪感，他们走在回家的路上。一边引用着《鸡应保有学说》里的理论，一边谈论着其他物种的基因劣势。鲍勃尤为激动他侃到“按这个增速不出50年，无论何地目光所及都是自己的同胞。“高谈阔论。慢慢队伍就剩鲍勃一只鸡，他讲得入了神，方向也慢慢迷失，走出了熟悉的鸡舍大门朝着一条马路走去却浑然不知。他晃晃悠悠的走着路突然踩到一坨热热的软软的东西。鲍勃一下子吓出了鸡叫～ 另外一边，这可以说是帅杰克此生中最为尴尬的时刻。稍微回退30分钟，他刚陪完客户，临走前看见洗手间的高档漱口水。不知道使用方法的他误吞服一大口。回家的路上，肚子疼的不行，停车到路边方便一下。 鲍勃嘴里逼逼叨叨：”我有优秀的基因，我们可是保有220亿基因的物种。什么生存环境对我们来说都不是问题，你们其他基因劣势的物种根本对我们造不成什么威胁。按这个增速不出50年，无论何地目光所及都是自己的同胞。到时候整个星球都是我们的…..。“ “果然，爱叫的鸡更美味，下次去养鸡场就要买这种爱逼逼的鸡。“帅杰克对着妻子说道。]]></content>
  </entry>
  <entry>
    <title><![CDATA[实用arcpy脚本合集]]></title>
    <url>%2F2019%2F11%2F21%2F%E5%AE%9E%E7%94%A8arcpy%E8%84%9A%E6%9C%AC%E5%90%88%E9%9B%86%2F</url>
    <content type="text"><![CDATA[Acrgis 是一个非常实用的GIS软件其中有很多强大的功能。但是随着处理数据的体量变得越来越大，结构化的数据包括了大量重复的内容。使用Arcpy模块调用Arcpy中的函数进行批处理可以大大减少工作时间避免重复的工作。下面是几个常用的Arcpy实例： 根据不同的省市分类不同的POI数据(一个csv文件根据不同地区和不同类别分为一个个小的csv文件)核心代码： 1234for city in citys: types = city[1].groupby(city[1]['type']) for typei in types: typei[1].to_csv(str(city[0])+str(typei[0])+'.csv',index = False,encoding = 'gbk') 完整示例 根据csv文件批量转成.shp文件其中涉及使用一个投影坐标文件.prj。可以在Arcgis坐标系文件处导出.prj文件。核心代码： 12gp.MakeXYEventLayer_management(intable, x_corrods, y_corrods, outlayer, spatial_ref)gp.FeatureClassToShapefile_conversion(outlayer, pathout) 完整示例 点到面的空间连接批量处理多个.shp文件空间连接到目标的面文件上。其中涉及的参数选择为保留的字段以及字段的计算统计等功能。核心代码： 1arcpy.SpatialJoin_analysis(target_features, join_features, out_feature_class,"#","#",fieldmappings) 完整示例 4.合并要对多个要素类进行合并。根据字段间的计算作为结果文件的字段。其中对于字段的保留和计算是其中的难点。核心代码： 1arcpy.Merge_management(in_file,output,fieldMappings) 完整示例 待更新…Ps:2019.11.21 在思考朝左边人放屁还是朝右边人时，听到了一声鸡叫…]]></content>
  </entry>
  <entry>
    <title><![CDATA[常用小脚本合集]]></title>
    <url>%2F2019%2F11%2F20%2F%E5%B8%B8%E7%94%A8%E5%B0%8F%E8%84%9A%E6%9C%AC%E5%90%88%E9%9B%86%2F</url>
    <content type="text"><![CDATA[记录一些常用的实用小脚本1.地理编码时常会用到批量获取POI 的经纬度坐标的需求，可以利用百度地图API提供的地理编码工具在线获取目标地址的经纬度坐标。 1http://api.map.baidu.com/geocoding/v3/?address=北京市海淀区上地十街10号&amp;output=json&amp;ak=您的ak //GET请求 完整示例 2.中英转换在收集资料时我们常常需要将excel表中的内容进行一些中英文翻译转换的工作，这个脚本调用在线翻译的api然后解析结果并写入文件中。核心代码 12345678910req_url = "http://fanyi.youdao.com/translate"From_Date = &#123;&#125;From_Date['i'] = 'I love you'From_Date['doctype'] = 'json'text = parse.urlencode(From_Date).encode('utf-8')response = request.urlopen(req_url,text)html = response.read().decode('utf-8')translate_result = json.loads(html)translate_result = translate_result['translateResult'][0][0]['tgt']translate_result 完整示例 待更新…Ps: 思考如何逃离无意义的人生本就是一件无意义的事 就像鸟儿想逃离天空 啷个跑的落嘛]]></content>
  </entry>
  <entry>
    <title><![CDATA[神经网路模型中各种优化器的原理及特点]]></title>
    <url>%2F2019%2F11%2F04%2F%E7%A5%9E%E7%BB%8F%E7%BD%91%E8%B7%AF%E6%A8%A1%E5%9E%8B%E4%B8%AD%E5%90%84%E7%A7%8D%E4%BC%98%E5%8C%96%E5%99%A8%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E7%89%B9%E7%82%B9%2F</url>
    <content type="text"><![CDATA[本篇博文旨在总结在神经网络训练过程中的各种使模型更快收敛的优化器(optimizer)的原理和特点。机器学习和深度学习的目标都是调整模型中参数的值使损失函数更快的收敛找到全局最小值。 Batch Gradient Descent梯度下降原理，是一个迭代模型。每次迭代通过从每个参数的负梯度方向调整参数值进而优化模型参数希望能够收敛。根据每次迭代所用到的数据量分为不同的小类，先介绍使用全部数据的Batch gradient descent.θ 是参数值, η 是学习率，最后一项是损失函数对θ 的偏导。Batch gradient descent 每次迭代用到了所有数据速度会很慢，同时因为数据集通常较大电脑内存装不下。 Stochastic Gradient Descent随机梯度下降是指每次使用数据集中的一个个例来进行参数优化的优化原理。x(i),y(i)表示数据集中一个样本的feature值和label在确保数据集完全随机后选取一个个例根据梯度下降的原则来进行调参。因为每次迭代采用一个样本点，在不断迭代中会有较强的震荡。 Min-Batch Gradient DescentMin-Batch gradient descent将数据集分成一定量的Min-batch 之后进行完全随机然后从中随机选取一个batch按照梯度下降的原理进行调参。x(i:i+n),y(i:i+n) 即表示一次迭代用作计算的数据，n是Min-batch的大小。 MomentumMomentum 可以加速SGD的参数优化速度同时还有抑制震荡的作用。Momentum 在之前的SGD的公式中添加了代表上一次迭代变化的附加项如图Momentum项γ通常取值为0.9.动量项的加入可以理解为一个趋势的项让调参方向不是完全根据当时的梯度方向而是考虑包含一个大趋势的方向。 Nesterov accelerated gradient(NAG)NAG是Momentum方法的一种改进和延伸，从公式上来看主要更改了之前的梯度项，将Momentum方法中的当前梯度方向更改为了累积梯度。优点和加入动量项一样首先可以减少震荡，让优化方向不那么剧烈的改变。减少震荡的同时有助于更快的收敛，训练速度变快。 AdagradAdagrad 的原理主要是：认为不同的参数在不同的迭代过程中应该有不同的学习率来优化参数。公式中G项累积了θi的之前的梯度累积用作调整θi在t时刻的学习率。从整体上来看随着迭代次数的增加，整体学习率会慢慢下降。优点是不用手动调节学习率参数，算法会自适应调节。缺点是单向的减小学习率会导致学习率太小进而模型不再学习。 AdadeltaAdadelta 算法是对Adagrad的一种拓展和优化算法。首先采取设定固定的窗口大小w，只有该次迭代前的窗口内的参数梯度会影响到这次迭代的学习率的控制，采用RME指数代替之前的平方和。改进了梯度增加学习率会一直下降的问题。 RMSpropRMSprop是Geoff Hinton提出的一种自适应学习率方法。Adagrad会累加之前所有的梯度平方，而RMSprop仅仅是计算对应的平均值，因此可缓解Adagrad算法学习率下降较快的问题。 AdamAdam优化算法基本上是对Momentum算法和RMSprop算法的结合。其中用于调整学习率的两项分别为一阶矩和二阶矩。这两项与Momentum和RMSprop的两项原理相似由两个超参数控制。经过改正后，进行学习率调整。Adam是目前应用最为广泛的优化算法之一。在大量数据集检验下有很好的调参效果。]]></content>
  </entry>
  <entry>
    <title><![CDATA[The Price]]></title>
    <url>%2F2019%2F07%2F12%2FThe-Price%2F</url>
    <content type="text"><![CDATA[The priceWhen you take away the gift of God, remember to ask the price. ———— Ming Paul是当代最著名的画家、行为艺术家。是现代人中最接近于神的存在。只要见过一眼他的作品的人都会被他的画作所吸引。 “偷了上帝调色盘的男人。” 人们都这样描述它。 其实他只是拿走了上帝调色盘的黑色。画作的其他部分都显得平庸除了每幅画中都会有一块纯黑的“黑洞”。他们像一颗一颗有生命的纯黑颗粒。 “P-Black”或者”Particle-Black”人们为那团黑命名。 今天，Paul宣布展出人生最后一幅作品，和公布一个秘密。社会名流统统到场，并有全球卫星实况转播，近50亿人同时观看。见证“神”的封笔之作。 幕布慢慢打开，画上只有一个黑色的大洞。全场人都安静了，全世界这一刻都安静了。可能连风也停止了流动。一切声音仿佛都被黑洞吸了进去。一切的一切。那一刻仿佛回到上帝造人之前。 随后的影片告诉了大家Paul的秘密。两年前，他还是一个失意的画家。他缓慢的画着画，拙劣的技巧，不断的被人们否定。他似乎从来不是一个画家的材料。他并不在意这些琐碎，他只想找到心中那份美。足以让他痴狂。那夜，它如同平常一样入睡。“调一个梦境的颜色”他心中想到。 “ Ultra Gate ” 一扇黑白相间的门。左边是最纯净的白，上面雕刻着一条一条的线，而右边是最无尽的黑，浮雕是一个一个的小点。 他瞥见了门外的世界，却迟迟忘不了那门上无尽的黑，这是他梦幻的色彩。他向前一步轻轻触碰，手指马上变黑和门上一样的黑。同时伴随着烧焦的气味。 梦醒了他兴奋不已，神情恍惚。 “Particle—Black”,他没有忘记梦中的黑。他砍掉自己的双腿，这对画家来说似乎比较多余。然后放进高温炉中火化，小心的取出剩下的焦炭研磨作画。 最后他跳进炉中完成了人生最后一幅作品。]]></content>
  </entry>
  <entry>
    <title><![CDATA[The one]]></title>
    <url>%2F2019%2F07%2F11%2FThe-one%2F</url>
    <content type="text"><![CDATA[The oneThe crazy man is the one. ———— Ming *“ 不要向前 ！”* *“ 不要向前 ！”* *“ 不要向前 ！”* *———— God* 上帝在创造人的时候同时给了人们这样三个告诫。 他是第一个疯子。他是一个普通的的人。样貌平平。在学生时代成绩也不突出，听父母的安排找了一份事业单位的工作。有一个同样普普通通的妻子。这似乎就是一个最为普通的人生一眼就能看到结束。如果一定要打一个分。60分应该是最为准确的。 但他似乎特别爱幻想做梦，或者更为准确 *Day Dream*。 那一天，普通的一天。可能对于一个他这样的普通人来说每一天都是普通的一天。他来到工位，习惯性的泡了杯茶，往椅子上一躺。开始了今天的白日梦。 和往常一样他先看见一扇巨大的门，左边是最纯净的白，上面雕刻着一条一条的线，而右边是最无尽的黑，浮雕是一个一个的小点。 *“ Ultra Gate ”* *———— God* 他在门口偷瞄里面的世界，那里光怪陆离，现实世界观无法解释。没有时间的绳索将世界连成串。一切都只是一个断点毫无牵连。 沉溺，他推开了门。 成了疯子。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Kaggle实战：Digit Recognizer]]></title>
    <url>%2F2018%2F11%2F20%2FKaggle%E5%AE%9E%E6%88%98%EF%BC%9ADigit-Recognizer%2F</url>
    <content type="text"><![CDATA[1. Data preparation 1.1 Load data 1.2 Check for null and missing values 1.3 Normalization 1.4 Reshape 1.5 Label encoding 1.6 Split training and valdiation set 2. CNN 2.1 Define the model 2.2 Set the optimizer and annealer 2.3 Data augmentation 3. Evaluate the model 3.1 Training and validation curves 3.2 Confusion matrix 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110# Data preparation#load datapd.read_csv#check data train.isnull().any().describe()train.head()train.describe()#Normolization # CNN deal with numbers in [0,1] faster then [0,255]train/255.0#reshapereshape image in 3-dimentionstrain.values.reshape(height,width,canal)#label encodingtrain_y = to_categorical(train_y,numberclasses)#split training and validation setstrain_test_split()----------# CNN model#define model#CNN architechture for example:#In -&gt; [[Conv2D-&gt;relu]*2 -&gt; MaxPool2D -&gt; Dropout]*2 -&gt; Flatten -&gt; Dense -&gt; Dropout -&gt; Outmodel = Sequential()model.add()#set optimizer and annealerkeras.optimizers.SGD(lr, momentum, decay, nesterov=False)keras.optimizers.RMSprop(lr, rho, epsilon=None, decay)compile(optimizer, loss=None, metrics=None, loss_weights=None, sample_weight_mode=None, weighted_metrics=None, target_tensors=None)learning_rate_reduction = ReduceLROnPlateau(monitor=&apos;val_acc&apos;, patience, verbose, factor, min_lr)epochesbatch_size#Data augmentation#to prevent overfitting ImageDataGenerator(featurewise_center=False, # set input mean to 0 over the datasetsamplewise_center=False, # set each sample mean to 0featurewise_std_normalization=False, # divide inputs by std of the datasetsamplewise_std_normalization=False, # divide each input by its stdzca_whitening=False, # apply ZCA whiteningrotation_range=10, # randomly rotate images in the range (degrees, 0 to 180)zoom_range = 0.1, # Randomly zoom image width_shift_range=0.1, # randomly shift images horizontally (fraction of total width)height_shift_range=0.1, # randomly shift images vertically (fraction of total height)horizontal_flip=False, # randomly flip imagesvertical_flip=False) # randomly flip imageshistory = model.fit_generator(datagen.flow(X_train,Y_train, batch_size=batch_size),epochs = epochs, validation_data = (X_val,Y_val),verbose = 2, steps_per_epoch=X_train.shape[0] // batch_size, callbacks=[learning_rate_reduction])----------# Evaluate the model# Plot the loss and accuracy curves for training and validation fig, ax = plt.subplots(2,1)ax[0].plot(history.history[&apos;loss&apos;], color=&apos;b&apos;, label=&quot;Training loss&quot;)ax[0].plot(history.history[&apos;val_loss&apos;], color=&apos;r&apos;, label=&quot;validation loss&quot;,axes =ax[0])legend = ax[0].legend(loc=&apos;best&apos;, shadow=True)ax[1].plot(history.history[&apos;acc&apos;], color=&apos;b&apos;, label=&quot;Training accuracy&quot;)ax[1].plot(history.history[&apos;val_acc&apos;], color=&apos;r&apos;,label=&quot;Validation accuracy&quot;)legend = ax[1].legend(loc=&apos;best&apos;, shadow=True)# Look at confusion matrix def plot_confusion_matrix(cm, classes,normalize=False,title=&apos;Confusion matrix&apos;,cmap=plt.cm.Blues):&quot;&quot;&quot;This function prints and plots the confusion matrix.Normalization can be applied by setting `normalize=True`.&quot;&quot;&quot;plt.imshow(cm, interpolation=&apos;nearest&apos;, cmap=cmap)plt.title(title)plt.colorbar()tick_marks = np.arange(len(classes))plt.xticks(tick_marks, classes, rotation=45)plt.yticks(tick_marks, classes)if normalize:cm = cm.astype(&apos;float&apos;) / cm.sum(axis=1)[:, np.newaxis]thresh = cm.max() / 2.for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):plt.text(j, i, cm[i, j],horizontalalignment=&quot;center&quot;,color=&quot;white&quot; if cm[i, j] &gt; thresh else &quot;black&quot;)plt.tight_layout()plt.ylabel(&apos;True label&apos;)plt.xlabel(&apos;Predicted label&apos;)# Predict the values from the validation datasetY_pred = model.predict(X_val)# Convert predictions classes to one hot vectors Y_pred_classes = np.argmax(Y_pred,axis = 1) # Convert validation observations to one hot vectorsY_true = np.argmax(Y_val,axis = 1) # compute the confusion matrixconfusion_mtx = confusion_matrix(Y_true, Y_pred_classes) # plot the confusion matrixplot_confusion_matrix(confusion_mtx, classes = range(10))]]></content>
      <tags>
        <tag>kaggle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2D横版游戏小结powered by GameMaker2]]></title>
    <url>%2F2018%2F09%2F26%2F2D%E6%A8%AA%E7%89%88%E6%B8%B8%E6%88%8F%E5%B0%8F%E7%BB%93powered-by-GameMaker2%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[算法小结快慢指针]]></title>
    <url>%2F2018%2F09%2F24%2F%E7%AE%97%E6%B3%95%E5%B0%8F%E7%BB%93%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;总结一些算法问题的思路和技巧，在处理链表的问题中经常会遇到寻找链表中间节点这样的问题，快慢指针(fast-slow pointer)就是一个很不错的工具。直接看题:A.判断链表是否有环并输出环入口节点 Linked List CycleGiven a linked list, determine if it has a cycle in it. Linked List Cycle IIGiven a linked list, return the node where the cycle begins. If there is no cycle, return null.142相较于141多了一个寻找环入口的步骤。这里给出142的代码： 1234567891011121314151617def FindListCycle(head): if not head: return None fast = slow = head#寻找是否存在环 while fast and fast.next: slow = slow.next fast = fast.next.next if fast == slow: break else: return None#找到环的入口 while head != slow: slow = slow.next fast = fast.next return head 利用快慢指针寻找环入口的数学原理：第一个循环中快慢指针相遇表示链表存在环，设slow走了N个节点；fast则走了2N个节点两指针相遇。此时保持两节点位置，让head从链表头遍历链表，head指针保持和slow一样每次一步的速度前进必定在slow走到2N(head走到N)时两指针相遇。在此位置之前相遇，相遇点即为环入口或是直到2N点初才相遇2Indian即是入口。 B.寻找链表中点 1234567def FindMiddleNode(head): if not head or not head.next: return None fast,slow = head while fast and fast.next: slow,fast = slow.next,fast.next.next return slow Sort ListSort a linked list in O(n log n) time using constant space complexity. 123456789101112131415161718192021def sortList(head): if not head or not head.next: return head # use fast-slow pointers to find the middle of the list # find the middle node and then sperate the list into two parts pre,slow,fast = None,head,head while fast and fast.next: pre,slow,fast = slow,slow.next,fast.next.next pre.next = None return self.merge(*map(self.sortList,(head,slow))) #merge sort def merge(self,h1,h2): dummy = tail = ListNode(None) while h1 and h2: if h1.val &lt; h2.val: tail.next,tail,h1 = h1,h1,h1.next else: tail.next,tail,h2 = h2,h2,h2.next tail.next = h1 or h2 return dummy.next Palindrome Linked ListGiven a singly linked list, determine if it is a palindrome.这道题可以利用list将每个节点的val存下来然后利用list的reverse方法翻转list与原来的list进行比较；不过要想达到空间复杂度O(1)则需要找到中间节点翻转后半节点进行比较。 123456789101112131415161718192021222324#方法一:使用list翻转，空间复杂度O(n)def isPalindrome(head): vals = [] while head: vals += head.val head = head.next return vals == vals[::-1]#方法二:使用快慢指针找中节点翻转后半链表def isPalindrome(head): fast = slow =head while fast and fast.next: slow,fast = slow.next,fast.next.next prev = None while slow: tmp = slow.next slow.next = prev prev = slow slow = tmp while slow: if slow.val != head.val: return False slow = slow.next head = head.next return True 遇到其他问题再更新…..]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Day 1 HongKong]]></title>
    <url>%2F2018%2F08%2F22%2FDay-1-HongKong%2F</url>
    <content type="text"><![CDATA[8月21号早上乘6：30的地铁来到福田口岸，地铁上还是有蛮多的人，急急忙忙上班的人，其实看得出来大家都挺不容易，可能每天上班都的很早起床然后挤公交。 从口岸过到香港这边乘坐东铁线到旺角东站，一路上感觉蛮累的，旁边人讲话也听不太懂。还是有一点陌生的感觉虽然都是黄皮肤的中国人。之前听阿姨讲内地来的和香港本地人会有很大的区别，一眼就能看出是内地过来的。我是没什么感觉了，不过香港上班族们好像都是西装领带，正装比较多一点其他没什么不一样。 来港之前在家最后一晚失眠挺严重的，感觉心里跳个不停。还是有一点舍不得家，舍不得父母和那种温馨的氛围。家里确实是我的舒适区，在家里都不怎么学习。哈哈，来到香港要好好的利用这边的资源，做一个积极的人了。 拖着行李来到公寓，3个小伙伴都先到了。其中一个的父母在给我们准备午餐，挺幸运的。一来就蹭到一顿吃喝。 然后收拾了一下自己的屋子，下楼买了一点生活用品。室友都挺热心的，感觉和大学宿舍的室友风格不太一样。可能心底里我还是更喜欢那一群老逼————他们是真的皮，好玩一点。 晚上约了上一届的一个学长，在理工的校园转了一转。第一次见到学长，学长面相比较man。上楼下楼各个楼里转悠，学长也是满头大汗，晚上和学长一起去红磡冰室吃了晚饭。 回来的路上，香港的老街还是很有味道，市井气息很浓。浓到我在楼下杂货铺买东西只能跟老板写汉字。这边的店员挺负责的，希望能充实的度过这一年。 # 生活的意义就是不断寻找生活意义的勇气。]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KMP 算法笔记]]></title>
    <url>%2F2018%2F08%2F05%2FKMP-%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[KMP算法是一种高效的串的模式配算法，由D.E.Knuth 与 V.R.Pratt 和 J.H.Morris 同时发现，因此被称为KMP算法。该算法可以在O（n+m)的时间数量级上完成串的模式匹配。 之前看过KMP算法的相关原理，无奈时间一长就渐渐淡忘了，现将学习笔记写入blog以备不时之需。 KMP算法俗称“看毛片”算法原理比较复杂比较绕，网上的博客有各种方向来理解他的，我将选用最容易理解的方式，简单形象的把他讲清楚。 整体把握 KMP算法的核心：模式串自身的相关性。即不匹配时模式串利用成功匹配的部分能将串后移的最大位数K。这是区别于传统模式匹配的地方。 Next函数的定义及计算在KMP算法匹配中原始串的索引 i 不会因不匹配而回退，利用Next函数调整模式串索引 j 值。当匹配失败时，利用当前 j 值求得 K = Next [ j ]，K即为最大右移量。使新的 j = K 继续匹配。Next的值实际上是对每个位置找最长公共前缀。 Next函数值的算法如下: 12345678910void get_next ( char T[],int next [])&#123; int i = 1, j = 0; next[1]=0; while(i&lt;=T[0])&#123; if(j==0||T[i]==T[j])&#123; ++i,++j,next[i]=j;&#125; else j=next[j]; &#125;&#125; 举例：求下面序列的Next数组值a b a a c b a b a(1)设next[1]=0,next[2]=1; 编号 1 2 3 4 5 6 7 8 9 S a b a a c b a b a next 0 1 1 2 2 1 1 2 3 (2)当 j = 3 时，K=next[ j -1]=1，因为是S[2]=b，S[K]=S[1]=a!=S[2]，此时K=next[K]=0,所以next[j]=K+1=1;(3)当 j=4时，K=next[ j -1]=1，因为是S[3]=a，S[K]=S[1]=a=S[3]，此时next[j]=k+1=2;(4)当 j=5时，K=next[ j -1]=2，因为是S[4]=a，S[K]=S[2]=b!=S[4]，此时K=next[K]=1,S[K]=S[4],所以next[j]=K+1=2;同理求出各个位置的next值。 KMP的匹配算法 相较于Next数组的求解过程，KMP的匹配算法理解了。 原始串的索引不断向前移动与模式串进行匹配，当匹配失败的将模式串的索引移至next[j]数组值的位置进行匹配直到匹配成功或是原始串末尾。 算法如下： 123456789101112131415int KMP (char s[],int next[],int pos)&#123; int i=pos; int j=1; while(i&lt;S[0]&amp;&amp;j&lt;T[0])&#123; //S[0],T[0]分别储存原始串和模式串的长度 if(j==0||S[i]==T[j])&#123; i++,j++; &#125; else j=next[j]; &#125; if (j&gt;T[0]) return i-t[0]; else return 0; &#125; 举例： 主串为：abcabaacabaacbaba，模式串为:abaacbaba，pos = 0： (1)初始化i=j=1; a b c a b a a c a b a a c b a b a a b a a c b a b a (2)S[1]=T[1]自加直到i=j=3时匹配失败，j=next[3]=1; a b c a b a a c a b a a c b a b a a b a a c b a b a (3)S[3]!=T[1],j=next[1]=0,模式串后移一位; a b c a b a a c a b a a c b a b a a b a a c b a b a (4)S[4]=T[1]自加匹配继续，直到i=9,j=6时匹配失败，j=next[6]=1; a b c a b a a c a b a a c b a b a a b a a c b a b a (5)匹配成功返回值：i-t[0]=17-9=8; 小结： KMP算法中核心部分为Next数组的求解，其中用到了动态规划的思想反复解算目标位置的next值，在这里没有对动态规划进行展开说明，接下来将以此为主题写几篇博文。]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>模式匹配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈与队列算法题小结]]></title>
    <url>%2F2017%2F10%2F16%2F%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E7%AE%97%E6%B3%95%E9%A2%98%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[一、getMin功能的栈 要求：a.在栈的基本功能上增加getmin返回栈内最小的元素; b.各种操作时间复杂度为O(1) 【解答】1.算法思想： a.总共两个栈stack_data 和 stack_min，stack_data 用于存放所有元素；stack_min 存放当前data栈中的最小元素 b.入栈时：设入栈元素为 cur,当stack_min栈为空时，cur压入stack_data栈时也压入min栈；当stack_min不为空时,需要比较cur与min 栈栈顶元素的大小：若 cur &lt;= stack_min.peek(),则cur压入min栈；否则不压。 c.出栈时：需要比较cur=stack_data.pop()与stack_min.peek():若cur=stack_min.peek(),则stack_min需弹出栈顶元素。 2.代码 123456789101112131415161718192021222324252627282930313233343536373839#getmin_stackimport collectionsclass getmin_stack(object): def __init__(self): self.stack_data=[] self.stack_min=[] def isEmpty(self): return self.stack_data==0 def push(self,element): self.stack_data.append(element) if len(self.stack_min)== 0: self.stack_min.append(element) else: a= self.stack_min[-1] if a &gt;= element: self.stack_min.append(element) print('data', self.stack_data) print('min', self.stack_min) def Pop(self): if not self.isEmpty(): if self.stack_data[-1]==self.stack_min[-1]: self.stack_min.pop() return self.stack_data.pop() def GetMin(self): if len(self.stack_min)!=0 : return self.stack_min[len(self.stack_min)-1]a=getmin_stack()a.push(2)a.push(3)a.push(2)a.push(1)print(a.GetMin())a.push(5)print(a.Pop())print(a.Pop())print(a.GetMin())print(a.Pop())print(a.GetMin())a.push(8) 二、由两个栈组成队列 要求：a.用两个栈来实现队列的基本操作(add, poll, peek)hsdjakuhdksua]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python yield 使用]]></title>
    <url>%2F2017%2F10%2F08%2FPython-yield-%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Ugly Numbers UVa 136]]></title>
    <url>%2F2017%2F07%2F07%2FUgly-Numbers-UVa-136%2F</url>
    <content type="text"><![CDATA[这道题解中用到了priority_queue和set两个stl容器。是熟悉stl容器类很好的例子。 Ugly numbers are numbers whose only prime factors are 2, 3 or 5. The sequence1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, …shows the first 11 ugly numbers. By convention, 1 is included.Write a program to find and print the 1500’th ugly number.InputThere is no input to this program.OutputOutput should consist of a single line as shown below, with ‘’ replaced by the number computed.Sample OutputThe 1500’th ugly number is . 12345678910111213141516171819202122232425262728#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;iostream&gt;using namespace std;typedef long long LL;const int coeff[3]=&#123;2,3,5&#125;;int main()&#123; priority_queue&lt;LL, vector&lt;LL&gt;, greater&lt;LL&gt; &gt; pq; set &lt;LL&gt; q; pq.push(1); s.insert(1); for(int i=0; ;i++)&#123; LL x = pq.top(); pq.pop(); if( i==1500)&#123; cout &lt;&lt; "The 1500'th ugly number is "&lt;&lt;x&lt;&lt;"./n"; break; &#125; for(int j=0;j&lt;3;j++)&#123; LL x2=x*coeff[j]; if(!s.count(x2))&#123; s.insert(x2);pq.push(x2);&#125; &#125; &#125; return 0;&#125; 1.]]></content>
      <tags>
        <tag>UVa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flooded! UVa815]]></title>
    <url>%2F2017%2F06%2F03%2FFlooded-UVa815%2F</url>
    <content type="text"><![CDATA[Recently, I am reading a book about ACM. In the Chapter 4, there is a exercise about my major. The book’s author tuck a few words on to the tail. Commend reader to solve this problem in different ways.I will use some special analytical method to resolve this problem. UVa815 —– Flooded! Description To enable homebuyers to estimate the cost of flood insurance, a real-estate firm provides clients with the elevation of each 10-meter by 10-meter square of land in regions where homes may be purchased. Water from rain, melting snow, and burst water mains will collect first in those squares with the lowest elevations, since water from squares of higher elevation will run downhill. For simplicity, we also assume that storm sewers enable water from high-elevation squares in valleys (completely enclosed by still higher elevation squares) to drain to lower elevation squares, and that water will not be absorbed by the land. From weather data archives, we know the typical volume of water that collects in a region. As prospective homebuyers, we wish to know the elevation of the water after it has collected in low-lying squares, and also the percentage of the region’s area that is completely submerged (that is, the percentage of 10-meter squares whose elevation is strictly less than the water level). You are to write the program that provides these results.InputThe input consists of a sequence of region descriptions. Each begins with a pair of integers, m and n, each less than 30, giving the dimensions of the rectangular region in 10-meter units. Immediately following are m lines of n integers giving the elevations of the squares in row-major order. Elevations are given in meters, with positive and negative numbers representing elevations above and below sea level, respectively. The final value in each region description is an integer that indicates the number of cubic meters of water that will collect in the region. A pair of zeroes follows the description of the last region.OutputFor each region, display the region number (1, 2, …), the water level (in meters above or below sea level) and the percentage of the region’s area under water, each on a separate line. The water level and percentage of the region’s area under water are to be displayed accurate to two fractional digits. Follow the output for each region with a blank line.Sample Input 3 325 37 4551 12 3494 83 27100000 0 Sample Output Region 1Water level is 46.67 meters.66.67 percent of the region is under water. Flooding model: function between the volume of flooding eare (V) and the altitude of the flood level (H): V = ∑ Ai * ( H - Ei) Ai–the area of flooded grid; Ei–the altitude of flooded grid; so the key of the problem is to choose the optimal H. c++ code 1234567891011121314151617181920212223242526272829303132333435363738394041# include &lt;cstdio&gt;# define minn 0.1# define mann 25vector &lt;double&gt; a[maxn]double compute( int i,int j,double vo,double h)&#123; double v; for(int i=0;i&lt;m;i++)&#123; for(int j=0;j&lt;n;j++)&#123; while(h-a[i][j] &gt; 0) v+=(h-a[i][j]); &#125; &#125; return v; &#125;int main()&#123; int m,n; double x,vo,v=0.0,al; int maxx,miin=0; scanf("%d%d", &amp;m, &amp;n); for (int i=0;i&lt;m;i++)&#123; for (int j=0;j&lt;n;j++)&#123; scanf("%f",&amp;x); a[i][j]=x; &#125; &#125; scanf("%f",&amp;vo); vo /= 100; maxx=vo; al=(maxx+miin)/2; while(abs(v-vo) &gt; 0.1)&#123; if(v-vo &gt; 0)&#123; maxx = al; al = (al + miin )/2; compute( m, n, vo, al); &#125; if(v-vo &lt; 0)&#123; miin = al; al = (al + maxx)/2; compute(m, n, vo,al); &#125; printf("%f",&amp;al); &#125;]]></content>
      <tags>
        <tag>UVa</tag>
        <tag>GIS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT (Advanced Level) 1003]]></title>
    <url>%2F2017%2F05%2F17%2FPAT-Advanced-Level-1003%2F</url>
    <content type="text"><![CDATA[Dijkstra算法遍历有向图过程中记录目标值，第一次实战Dijkstra，有点小激动，问题也不少。 Emergency (25) As an emergency rescue team leader of a city, you are given a special map of your country. The map shows several scattered cities connected by some roads. Amount of rescue teams in each city and the length of each road between any pair of cities are marked on the map. When there is an emergency call to you from some other city, your job is to lead your men to the place as quickly as possible, and at the mean time, call up as many hands on the way as possible. Input Each input file contains one test case. For each test case, the first line contains 4 positive integers: N (&lt;= 500) - the number of cities (and the cities are numbered from 0 to N-1), M - the number of roads, C1 and C2 - the cities that you are currently in and that you must save, respectively. The next line contains N integers, where the i-th integer is the number of rescue teams in the i-th city. Then M lines follow, each describes a road with three integers c1, c2 and L, which are the pair of cities connected by a road and the length of that road, respectively. It is guaranteed that there exists at least one path from C1 to C2. Output For each test case, print in one line two numbers: the number of different shortest paths between C1 and C2, and the maximum amount of rescue teams you can possibly gather.All the numbers in a line must be separated by exactly one space, and there is no extra space allowed at the end of a line.Sample Input 5 6 0 21 2 1 5 30 1 10 2 20 3 11 2 12 4 13 4 1 Sample Output 2 4问题描述:讲了个故事，有若干个城市，城市之间有若干条带权有向路径，每个城市都驻扎着若干救援队，求当某个城市发生紧急状况需要救援时，到该城市的最短路径有几条，并输出救援队数目(如有多条最短路径输出救援队数目最多的) C++代码:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152# include &lt;cstdio&gt;# include &lt;algorithm&gt;using namespace std;const maxn = 505;int map[maxn][maxn],v[maxn]; //储存有向图的边权有向图的顶点属性值，int visit[maxn],dist[maxn],num[manx],vs[maxn]; //算法中的辅助数组分别是访问数组，最短路径数组，路径数量数组int m,n,c1,c2,v,a,b,e;int main()&#123;//----------------建立相应的数据结构，完成数据初始化------------------- scanf("%d%d%d%d",&amp;m,&amp;n,&amp;c1,&amp;c2); memset(map,maxn,sizeof(map)); memset(v,manx,sizeof(v)); for( int i=0;i&lt;m;i++)&#123; scanf("%d",&amp;v); v[i]=v; &#125; for( int i=0;i&lt;n;i++)&#123; scanf("%d%d%d",&amp;a,&amp;b,&amp;e); map[a][b]=map[b][a]=e; &#125;//--------------Dijkstra遍历部分------------------------------- memset(visit,0,sizeof(visit)); dist[c1]=0; vs[c1]=v[c1]; num[c1]=1; for( int i=0;i&lt;m;i++)&#123; int now=-1,min=maxn; for( int j=0;j&lt;m;j++)&#123; if( !visit[j] &amp;&amp; dist[j] &lt; min)&#123; u=j; min=dist[j]; &#125; &#125; //寻找未访问的最小权值边所在顶点j if(u==-1)break; visit[j]=1; for( int k=0;k&lt;n;k++)&#123; if( !visit[k] &amp;&amp; map[u][k] &lt; maxn)&#123; if(dist[u]+map[u][k]&lt;dist[k])&#123; dist[k]=dist[u]+map[u][k]; num[k]=num[u]; vs[k]=vs[u]+v[k]; &#125; else if (dist[u]+map[u][k] = dist[k])&#123; num[k]+=num[u]; if(vs[u]+v[k]&gt;vs[k])vs[k]=vs[u]+v[k]; &#125; &#125; &#125; &#125; printf("%d%d",num[c2],vs[c2]); return 0;&#125;]]></content>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dijkstra 算法笔记]]></title>
    <url>%2F2017%2F05%2F17%2FDijkstra-%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[关于Dijkstra算法的本质是贪心算法还是动态规划，大家可以去看看大牛们的理解，作为一个学习者我也没什么独到的理解，不过看看大家的观点也没什么害处，毕竟兼听则明。 Dijkstra算法是求解单源最短路径的有效方法。一、相关辅助数组 Visit[]: 记录是否访问过某个节点，当visit[vi]=1时，表示将顶点vi 放入visit[]中； dist[]: 记录从源点v0到各顶点当前的最短路径长度，dist[]初值为ma p[vo][i]; path[]: path[i]表示从源点到顶点i的最短路径的前驱节点。 二、算法步骤 假设从顶点0出发，即v0=0，集合visit[]最初只包含顶点0，v[] 表示顶点集合及其属性值。邻接矩阵 map 表示带权有向图，map[i][j]表示有向边 &lt;i,j&gt; 的权值，若不存在 &lt;i,j&gt;,则map[i][j]为 ∞。 1).初始化: 集合visit[]初始化为{0}，dist[]的初始值 dist[] = map[0][i]; 2).从顶点集合v-visit中选出vj，满足dist[j] = Min { dist[j] | vi ∈ v-visit },vj就是求得一条从v0出发的最短路径的终点，把 j 加入visit[]； 3).修改从v0出发到集合v-visit上任意一点vk可达到的最短路径长度:如果 dist[j]+map[j][k] &lt; dist[k],则dist[k] = dist[j]+map[j][k]; 4).重复2)-3)操作n-1次，直到所有顶点都包含在visit[]中； 三、实例 例如，如下有向图求解从图中顶点0出发，到其余顶点的最短路径： 顶点 第一趟 第二趟 第三趟 第四趟 1 v0→v1 100 v0→v2→v1 90 v0→v4→v3→v1 70 2 v0→v2 30 v0→v2 30 3 v0→v4→v3 60 v0→v4→v3 60 4 v0→v4 10 visit {0,4} {0,4,2} {0,4,2,3} {0,4,2,3,1} 上表反映了例中有向图使用Dijkstra算法求顶点0到各顶点最短路径的过程。 四、相关习题 在算法题解的过程中有关Dijkstra算法的题会贴到下面: 大家可以从习题求解的过程中更好的理解Dijkstra算法。]]></content>
      <tags>
        <tag>最短路径</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法思想——动态规划(Dynamic programing)]]></title>
    <url>%2F2017%2F05%2F15%2F%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-Dynamic-programing%2F</url>
    <content type="text"><![CDATA[WebGis的课程上老师让有个小组展示，主要内容是最近所学，最近学习算法，思来想去干脆做个有关算法思想的介绍。 概念： 动态规划(Dynamic programing)中:Dynamic当然是动态的意思了。然而programing却有另一种解释:”programing”指的是一种表格法，并非编写计算机程序。(这是《算法导论》上的解释）。动态规划常用来解决最优化问题，与分治法十分相似，其基本原理是将待求问题分为若干子问题，通过求解子问题得到原问题的解。 适用条件： 1&gt;最优化原理:一个最优化策略具有这样的性质，不论过去状态和决策如何，对前面的决策所形成的状态而言，余下的诸决策必须构成最优策略。简而言之，一个最优化策略的子策略总是最优的。 2&gt;无后效性:以前各阶段的状态都无法直接影响它未来的决策，每个状态都是对过去的一个完整总结。 3&gt;子问题重叠性:动态规划将原来具有指数级时间复杂度的搜索算法改进成了具有多项式时间发杂度的算法，是一种牺牲空间换时间的算法。 以01背包为例理解动态规划原理及特点： 01背包问题:给出物品重量 W[n]={w1,w2,w3,w4,w5…,wn},物品价值 V[n]={v1,v2,v3,v4,v5….vn},以及背包最大承重量 c=K，求背包能容纳的最大价值为多少？ (PS:每种物品只能选一次，对于物品而言1代表选，而0为不选，因此命名“01背包问题”) 例. 物品重量W[5]={2,3,6,4},物品价值 V[5]={4,7,15,10},背包最大承重量 c=10,求能容纳的最大价值？ 设m[i][j]表示可选物品为i…n背包容量为j时背包能容纳物品的最大值。 价值重量表： w 0 2 3 6 4 v 0 4 7 15 10m[i][j]表: 0 1 2 3 4 5 6 7 8 9 10 1 0 2 7 10 11 15 17 19 19 25 2 0 0 7 10 10 15 17 17 17 25 3 0 0 0 10 10 15 15 15 15 25 4 0 0 0 10 10 10 10 10 10 10 12345678m[i][j]=&#123; if(j&gt;=wi) max&#123; m[i+1][j],m[i+1][j-wi]+vi&#125;; if(0&lt;=j&lt;=wi) m[i+1][j] &#125;m[n][j]=&#123; if(j&gt;=wn) vn; if(j&lt;wn) 0 &#125; 根据以上原则，自底而上，从左至右填充m[i][j]表，最终m[1][10]即为结果。]]></content>
      <tags>
        <tag>算法思想</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT(Advanced Level) 1002]]></title>
    <url>%2F2017%2F05%2F12%2FPAT-Advanced-Level-1002%2F</url>
    <content type="text"><![CDATA[1002题一道25分的题是甲级考试中中等难度的题，和昨天的那题不太一样。C++部分我很快就有了思路，比较轻松的完成了这部分；至于Python部分头有点大，各种字符串切片划分操作忘得一干二净，一晚上都在痛苦的报错。 A+B for Polynomials (25) This time, you are supposed to find A+B where A and B are two polynomials. Input Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial: K N1 aN1 N2 aN2 … NK aNK, where K is the number of nonzero terms in the polynomial, Ni and aNi (i=1, 2, …, K) are the exponents and coefficients, respectively. It is given that 1 &lt;= K &lt;= 10，0 &lt;= NK &lt; … &lt; N2 &lt; N1 &lt;=1000. Output For each test case you should output the sum of A and B in one line, with the same format as the input. Notice that there must be NO extra space at the end of each line. Please be accurate to 1 decimal place.Sample Input 2 1 2.4 0 3.22 2 1.5 1 0.5 Sample Output 3 2 1.5 1 2.9 0 3.2 问题描述:两多项式相加求和问题；输入:两行分别代表两个多项式，第一个数字为项数，后面依次为指数，系数，指数，系数…….输出:同输入格式一致表示结果 Python代码: 1占个坑.... C++代码: 1234567891011121314151617181920212223242526# include &lt;cstdio&gt;using namespace std;const int maxn = 1010;float rs[maxn],f;int n,a;int cnt=0;int main()&#123; for (int i=0;i&lt;2;i++)&#123; scanf("%d",&amp;n); while(n--)&#123; scanf("%d%f",&amp;a,&amp;f); rs[a]+=f; &#125; &#125; for (int i=0;i&lt;maxn;i++)&#123; if(rs[i]!=0)cnt++; &#125; printf("%d",cnt); for (int i=maxn-1;i&gt;=0;i--)&#123; if(rs[i]!=0)&#123; printf(" %d %.1f",i,rs[i]); &#125; &#125; printf("\n"); return 0;&#125; 总结:1.C++部分即是用好数组，简化问题；2.至于Python部分的代码为什么还没贴，我写的感觉还不太满意，不是特别pythonic，会补上的；]]></content>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT (Advanced Level) 1001]]></title>
    <url>%2F2017%2F05%2F11%2FPAT-Advanced-Level-1001%2F</url>
    <content type="text"><![CDATA[今天终于开始了PAT甲级题库，为了9月份的PAT考试，题库的每一道题我都会写进博客里的。之前学过的Python发现忘得很厉害很彻底，所以我准备每题都写Python和C++两个版本，至于其他语言好像无缘了，毕竟考研很多事情。代码我会放到我的GitHub，如果有迷路的盆友有兴趣，可以找我玩耍呀！ ——————————————-这是分割线———————————————————- A+B Format (20)Calculate a + b and output the sum in standard format – that is, the digits must be separated into groups of three by commas (unless there are less than four digits).Input Each input file contains one test case. Each case contains a pair of integers a and b where -1000000 &lt;= a, b &lt;= 1000000. The numbers are separated by a space. Output For each test case, you should output the sum of a and b in one line. The sum must be written in the standard format.Sample Input -1000000 9 Sample Output -999,991问题描述：输入a,b两个整数，空格隔开；格式化输出两者和； Python代码： 12345def formatout(contents): num = map(int,contents.split()) num = num[0] + num[1] return '&#123;:,&#125;'.format(num)print formatout(raw_input()) C++代码： 123456789101112131415161718192021222324252627# include &lt;cstdio&gt;# include&lt;iostream&gt;# include&lt;cstring&gt;using namespace std;int main()&#123; int a,b,c,k,num[100000]; int i=0; scanf("%d%d",&amp;a,&amp;b); c=a+b; if(c&lt;0)&#123; c=-c; printf("-"); &#125; while(c)&#123; num[i++]=c%10; c/=10; &#125; for(k=i-1;k&gt;=0;k--)&#123; printf("%d",num[k]); if(k%3 == 0 &amp;&amp; k) printf(","); &#125; if(!i)printf("0"); printf("\n"); &#125; 总结： 1.Map/Reduce: 提到Map函数不得不提Google大名鼎鼎的论文:MapReduce:simplified data processing on large clusters还有这篇国人的例子很生动 用通俗易懂的大白话讲解Map/Reduce原理 2.raw_input ()和input():简而言之input ()函数接受输入时，内容必须符合Python语法规则即input()函数返回值带有数据类型(int,float,str…);raw_input()则把输入内容一律按字符串返回。]]></content>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[这是一篇测试文你可以不应看了]]></title>
    <url>%2F2017%2F05%2F07%2F%E8%BF%99%E6%98%AF%E4%B8%80%E7%AF%87%E6%B5%8B%E8%AF%95%E6%96%87%E4%BD%A0%E5%8F%AF%E4%BB%A5%E4%B8%8D%E5%BA%94%E7%9C%8B%E4%BA%86%2F</url>
    <content type="text"><![CDATA[你还是点开了……诶！？调皮。这是刀塔没我炉石没我（曾用名：全自动打屁屁机）的Blog，简单几句话解决这一篇： -上帝已死-英雄不朽-跳刀躲梅肯-死吧！虫子！]]></content>
  </entry>
</search>
